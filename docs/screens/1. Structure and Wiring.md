# Screen Structure and Wiring

This document explains **how a feature screen is structured** in Baselines and **how its pieces are wired together**.
Each component has a single responsibility and a clear place in the flow from user interaction to UI rendering.

The goal is:

- Predictable screen structure
- Explicit data flow
- Minimal recompositions
- Easy testability and maintenance

---

## Overview: How a Screen Is Composed

A feature screen is built from the following building blocks:

1. **`UiEvent`** â€” user intent
2. **`UiState`** â€” single source of truth for rendering
3. **`ViewModel`** â€” UI logic and state producer
4. **`Screen`** â€” pure UI
5. **`Route`** â€” wiring layer
6. **`UiModule`** â€” dependency injection and navigation registration

Each layer exists to **separate concerns and keep the UI stable** as the feature grows.

---

## 1. `UiEvent` â€” Capturing User Actions

**Responsibility:** Represent everything the user can do on the screen.

`UiEvent` is a sealed type that enumerates all user interactions such as clicks, gestures, or selections.

```kotlin
sealed interface ProfileUiEvent : UiEvent {
    data object OnLogoutClicked : ProfileUiEvent
}
```

> **Guidelines:**
> * Model **intent**, not UI mechanics.
> * Start minimal and grow as the feature evolves.
> * Avoid passing lambdas directly through the UI.

---

## 2. `UiState` â€” Single Source of Truth

**Responsibility:** Hold all data required to render the screen.

The UI reads from `UiState` only. There is no implicit state hidden in the composables.

```kotlin
@Immutable
data class ProfileUiState(
    override val eventSink: (ProfileUiEvent) -> Unit,
) : UiState<ProfileUiEvent>
```

> **Guidelines:**
> * Annotate with `@Immutable` to reduce recompositions.
> * Keep state explicit.
> * If the state grows, split it into smaller nested data classes.

---

## 3. `ViewModel` â€” UI Logic and State Producer

**Responsibility:** Own UI logic and produce `UiState`.

The ViewModel:

* Coordinates domain logic.
* Transforms data into UI-ready state.
* Exposes a single `state()` entry point.

```kotlin
@Inject
class ProfileViewModel : BaselineViewModel<ProfileUiEvent, ProfileUiState>() {

    private val sectionsFlow =
        mutableState(persistentListOf()) { createSections() }

    @Composable
    override fun state(): ProfileUiState {
        val sections by sectionsFlow.collectAsStateWithLifecycle()
        return ProfileUiState(
            sections = sections,
        ) { event ->
            when (event) {
                ProfileUiEvent.OnLogoutClicked -> handleLogout()
            }
        }
    }

    private fun handleLogout() {
        /* domain coordination */
    }

    private suspend fun createSections(): ImmutableList<Section> {
        /* data preparation */
    }
}
```

### Why `state()` is composable

`state()` is marked `@Composable` so it can:

1. Participate in Compose snapshots.
2. Automatically recompose when state changes.
3. Expose stable references to the UI.

---

## 4. `Screen` â€” Pure UI Layer

**Responsibility:** Render UI only.

The `Screen`:

* Contains no logic.
* Holds no state.
* Forwards user interactions via callbacks.

```kotlin
@Composable
fun ProfileScreen(
    sections: ImmutableList<Section>,
    onLogoutClicked: () -> Unit,
) {
    /* UI layout */
}
```

> **Guidelines:**
> * Keep screens stateless.
> * **Never** call ViewModel directly.
> * Treat callbacks as event emitters only.

---

## 5. `Route` â€” Wiring State to UI

**Responsibility:** Bind ViewModel state to the Screen.

The `Route`:

* Pulls state from the ViewModel.
* Extracts stable references.
* Connects UI callbacks to `UiEvents`.

```kotlin
@Composable
fun ProfileRoute(viewModel: ProfileViewModel) {
    val state = viewModel.state()
    val eventSink = state.eventSink
    ProfileScreen(
        sections = state.sections,
        onLogoutClicked = {
            eventSink(ProfileUiEvent.OnLogoutClicked)
        },
    )
}
```

> ðŸ’¡ State provided by the ViewModel may change frequently. By extracting `eventSink` outside callbacks/lambdas you make
> sure
> Compose treats them as stable objects and avoid redundant recompositions.

### Why this layer exists

Separating the Route:

* Keeps screens pure.
* Prevents accidental recompositions.
* Centralizes wiring logic.

---

## 6. `UiModule` â€” Dependency Injection and Navigation

**Responsibility:** Register the screen in the navigation graph.

The `UiModule`:

* Contributes navigation entries.
* Wires ViewModel factories.
* Keeps navigation setup out of UI code.

```kotlin
@ContributesTo(UiScope::class)
interface ProfileUiModule {

    @Provides
    @IntoSet
    fun provideProfileNavGraphEntry(
        profileVmFactory: () -> ProfileViewModel,
        editVmFactory: () -> EditProfileViewModel,
    ): NavGraphEntry = NavGraphEntry {
        composable<AppNavRoutes.Profile> {
            ProfileRoute(viewModel(profileVmFactory))
        }
        composable<AppNavRoutes.EditProfile> {
            EditProfileRoute(viewModel(editVmFactory))
        }
    }
}
```

> **Guidelines:**
> * Use unique `provideâ€¦` function names.
> * `vmFactory` is auto-generated for `@Inject` ViewModels.
> * Multiple routes can be registered in one module.

---

## Mental Model

Think of a screen as a pipeline:

User Action â†’ UiEvent â†’ ViewModel â†’ UiState â†’ Screen

Each layer has:

* **One responsibility**
* **One direction of data flow**
* **No hidden coupling**

---

## Further Reference

For a more advanced example that:

* Combines multiple flows
* Reflects loading and error states
* Demonstrates complex state coordination

See **`PlaygroundViewModel`**.

# Implementing Business Logic

## Using `Worker` and `Observer`

This document explains **how to write and use domain-level business logic** in Baselines using two core primitives:

- **`Worker`** — for one-time business operations
- **`Observer`** — for continuous or reactive business state

If you are implementing **custom business logic** in the domain layer, this is the entry point.

---

## Why `Worker` and `Observer` Exist

Baselines enforces a strict separation between **UI**, **domain logic**, and **data access**.

Business logic must:

- be explicit
- be testable
- fail safely
- not depend on UI or platform code

`Worker` and `Observer` provide a **standardized way** to express business intent while enforcing these rules.

---

## When to Use Which

| Scenario                | Use        |
|-------------------------|------------|
| Fetch data once         | `Worker`   |
| Submit or mutate data   | `Worker`   |
| Trigger an action       | `Worker`   |
| Observe state over time | `Observer` |
| React to data changes   | `Observer` |
| Stream updates to UI    | `Observer` |

---

## Writing a `Worker`

A `Worker` represents a **single business operation**.

It:

- runs once
- returns a `Result`
- **safely captures failures**
- always reports success or failure explicitly

### Important: Exception Handling

It is **safe and intentional** to throw exceptions inside a `Worker`.

Any exception thrown from `doWork`:

- **will not crash the app**
- is automatically captured
- is returned as `Result.Failure`
- is handled via `onFailure { ... }`

This allows you to use exceptions for **clear control flow** in domain logic without leaking crashes into the UI layer.

### Example

```kotlin
// Domain layer
@Inject
class GetStartRoute(
    private val checkAuthenticated: CheckAuthenticated,
) : Worker<Unit, NavRoute>() {

    override suspend fun doWork(params: Unit): NavRoute {
        val authenticated = checkAuthenticated(Unit).getOrThrow()
        return if (authenticated) {
            AppNavRoutes.Home
        } else {
            AppNavRoutes.Auth
        }
    }
}

// Usage
@Inject
class StartRouteInitializer(
    private val getStartRoute: GetStartRoute,
) : AsyncInitializer {

    override suspend fun init() {
        getStartRoute(Unit)
            .onSuccess { /* Assign the default start route */ }
            .onFailure { /* Handle error state explicitly */ }
    }
}
```

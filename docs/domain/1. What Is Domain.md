# What is Domain?

The **domain layer** represents the **core business logic** of your application â€” the part that defines how your
system behaves according to the rules and requirements **specific to your product or business**.
Unlike other layers (like data or UI), the domain layer is platform-agnostic and independent of frameworks or
infrastructure.

Think of it as the **"what"** your app does, not **"how"** it's displayed or where the data comes from.

---

## What Belongs in the Domain Layer?

You should place code here if it:

- Encapsulates **business rules or decisions**.
- Coordinates **multiple operations** across repositories or data sources.
- Should be **reused** across different layers (e.g., ViewModel, background tasks).
- It is **independent of Android/iOS/UI or DB frameworks**.

Examples:

- Authentication rules.
- User eligibility checks.
- Subscription billing logic.
- Health metric calculations.
- Decision-making policies (e.g., "Should this reminder be triggered now?").

## Best Practices

- **Use pure Kotlin**: No Android, no UI toolkit, no framework dependencies.
- **Favor immutability**: Inputs and outputs should be value types where possible.
- **Be deterministic**: Given the same input, output should be predictable.
- **Keep it testable**: Domain logic should be easy to unit test without mocks or setup code.
- **Define interfaces/models separately from implementation**: To facilitate this, the `domain` module contains an inner
  `domain:api` module which includes only interfaces and data models. This is useful when other modules (like
  navigation)
  need to use domain models without depending on the full domain implementation.
- **Group logic in use-cases**: instead of spreading across models or utils.
